# Google Chubby

Прочтите статью [The Chubby lock service for loosely-coupled distributed systems](https://ai.google/research/pubs/pub27897)

## Вопросы

* Зачем вообще нужен сервис блокировок?
* Что будет с захваченным локом, если клиент, взявший его, умрет?
* Какой протокол консенсуса используется в _Chubby_ для репликации состояния?
* Зачем в системе нужно понятие _сессии_? 
* Могут ли два клиента системы одновременно думать, что они владеют блокировкой?
* Может ли сессия разорваться, если и клиент и мастер живы? 
* Из чего состоит _sequencer_? Как он связан с блокировками, когда нужно им пользоваться?
* Когда _Chubby_ использует _lock delay_ и зачем?
* Разрывается ли сессия в случае смерти мастера ансамбля реплик _Chubby_?
* Почему новый мастер _Chubby_ во время процедуры fail-over-а инвалидирует кэши клиентов?
* Как в процедуре выбора лидера применяется операция `SetContents`?
* Клиенты _Chubby_ локально кэшируют данные для последующих чтений. Может ли клиент читать из кэша устаревшие данные из узла, который перезаписал другой клиент?
* Если сессия клиента переходит в состояние _jeopardy_, то локальный кэш клиента сбрасывается. Почему?
* В чем отличие кэширования в _ZooKeeper_ от кэширования в _Chubby_?
* Почему в модели данных и API _ZooKeeper_ нет блокировок?
* Гарантирует ли _ZooKeeper_ линеаризуемость для чтений и почему?
* Как обслуживаются read-only запросы в _Chubby_? Гарантируется ли для них линеаризуемость?
* Приведите пример использования _Chubby_ в _BigTable_.
* В модели данных и API _ZooKeeper_ нет блокировок, они реализуются с помощью _рецепта_. В чем отличие рецептов блокировки, которые используются системами Kafka и в ClickHouse?
* Почему системы называются _Chubby_ и _ZooKeeper_?

---

Если вопрос связан с фактом из статьи или другого источника, то приведите цитату из статьи или удобным образом сошлитесь на релевантный фрагмент.
Если на вопрос можно ответить "да" или "нет", то обязательно аргументируйте свой выбор.