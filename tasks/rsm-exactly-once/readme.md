## Семантика exactly-once для клиента RSM

Пусть вы реплицируете произвольный автомат (дерево метаданных для распределеной файловой системы или _таблет_ распределенного K/V хранилища) с помощью _SMR_ (_State Machine Replication_, например Multi-Paxos или RAFT).

Вероятно ваш автомат поддерживает неидемпотентные операции, например, `Сreate`, `Lock`, `Compare-And-Set` и т.п.

Отправляя запрос с операцией в распределенную систему, клиент (клиентская библиотека) заводит таймаут, в течение которого ждет от системы результата / подтверждения операции. 

Если таймаут истек, а клиент не получил ответа, то он в затруднительном положении, поскольку не различает следующие сценарии:

- Узел, на который была отправлена команда, умер до ее обработки, команда не применилась к реплицированному автомату
- RSM применил команду, но узел не успел ответить клиенту за отведенное время (из-за сборки мусора, тормозов диска и т.п.)

Если клиент будет ретраить свои неподтвержденные операции, то есть риск применить некоторые изменения дважды (семантика _at-least once_), если не будет ретраить, то некоторые изменения просто не достигнут системы (семантика _at-most once_).

Ретрай не подразумевает, что запрос приземлится на ту же реплику, что и в предыдущий раз: исходная реплика могла отказать.

Разработайте протокол клиента и механизм внутри системы, который обеспечивает семантику _exactly-once_ для операций клиента. Можно считать, что различных клиентов разумное количество, а вот запросов может быть сколь угодно много. Аккуратно продумайте все детали вашего решения, а не просто общую идею.
