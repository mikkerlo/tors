## TrueTime и атомарный регистр

На второй лекции был рассмотрен алгоритм репликации атомарного регистра ABD (по фамилиям авторов – _Attiya, Bar-Noy, Dolev_) с операциями `Get` и `Set`.
Под атомарностью регистра понималась самая сильная модель согласованности – [линеаризуемость](https://jepsen.io/consistency/models/linearizable).

Записи в алгоритме аннотировались и упорядочивались временными метками, причем для них требовалась _монотонность_: если запись $`w'`$ началась после завершения записи $`w`$, то она должна была получить временную метку строго больше: $`ts(w') > ts(w)`$. Интуитивно, монотонность позволяла согласовать взгляд на порядок записей для клиентов системы и реплик:
* Для реплик порядок записей задается лишь временными метками.
* Клиенты наблюдают порядок операций в физическом времени (правда не напрямую, ведь у них нет и не может быть синхронизированных локальных часов, а косвенно, через коммуникацию и причинность).

Для случая одного писателя временные метки назначались тривиально: писатель поддерживал локальный счетчик и инкрементировал его на каждую запись.

В случае нескольких писателей в операцию `Set` потребовалось добавить дополнительную фазу кворумного чтения: писатель собирал временные метки с кворума реплик и выбирал для своей записи временную метку по правилу [логических часов Лэмпорта](https://en.wikipedia.org/wiki/Lamport_timestamps).

В этой задаче вы должны избавиться от этой фазы чтения для общего случая нескольких писателей и придумать механизм генерации временных меток для записей, который не требует синхронной коммуникации с узлами системы. Для этого вам предоставляется сервис _TrueTime_ (далее – _TT_):

Сервис _TT_ реализует единственный вызов `Now()`, который возвращает интервал $`[l,h]`$, в котором заключено текущее время. Чуть строже, пусть клиент отправил свой запрос к сервису _TT_ в момент времени $`t_0`$ и получит ответ $`[l,h]`$ в момент времени $`t_1`$. Гарантируется, что интервалы  $`[t_0,t_1]`$ и $`[l,h]`$ пересекаются. При этом сами времена $`t_0`$ и $`t_1`$ клиенту конечно же неизвестны, у него нет точных локальных часов.

Сама реализация _TrueTime_ разумеется требует коммуникации между узлами, но эта коммуникация фоновая и асинхронная. Клиент, вызывая `Now()`, обращается не к удаленному сервису, а к локальному модулю TT, который оценивает неопределенность и выдает временной интервал. 

Подробнее про реализацию _TrueTime_ можно прочесть в статье про [Google Spanner](https://ai.google/research/pubs/pub39966). Дополнительно – [Spanner, TrueTime and the CAP Theorem](https://ai.google/research/pubs/pub45855).
