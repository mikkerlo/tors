## Timestamp Oracle

_Изоляция снапшотов_ (_Snapshot Isolation_, _SI_) – один из алгоритмов изоляции транзакций (буква _I_ в акрониме [ACID](https://www.youtube.com/watch?v=5ZjhNTM8XU8)), который позволяет выполнять чтения без блокировки пишущих транзакций.

В алгоритме _SI_ каждая транзакция получает две временные метки $`t_{start}`$ и $`t_{commit}`$:

- Метка $`t_{start}`$ выдается на старте транзакции и фиксирует _снапшот_ (_снимок_) – статичную версию хранилища, которую транзакция будет читать.
- Метка $`t_{commit}`$ генерируется во время коммита транзакции. Под этой меткой в хранилище будут сохранены все записи, сделанные транзакцией.

На лекции про распределенные транзакции мы рассмотрели реализацию протокола SI на примере распределенного хранилища [Google BigTable](https://ai.google/research/pubs/pub27898) и клиентского протокола транзакций [Google Percolator](https://ai.google/research/pubs/pub36726).

За назначение транзакциям временных меток в этом дизайне отвечал отдельный сервис – _TimeStamp Oracle_ (далее – _TSO_) с единственной операцией `GetTimestamp()`, которая выдает монотонные целые числа. Никакой привязки временных меток к физическому времени от _TSO_ не требуется, нужна лишь монотонность.

Монотонность означает, что если клиент _B_ отправил оракулу запрос `GetTimestamp` строго после (в физическом времени) того, как клиент _A_ получил от оракула ответ, то клиент _B_ получит временную метку строго больше, чем клиент _A_.

Отказоустовость всей конструкции складывается из следующих слагаемых:

- Каждый шард (_таблет_) распределенного хранилища являлся отказоустойчивой сущностью (можно считать, что таблет – это реплицированный через Multi-Paxos или RAFT автомат) и хранит все данные и блокировки
- Клиенты отказоустойчивыми не являются, но реализуют _lock-free_ протокол распределенных транзакций. _Lock-freedom_ в данном контексте означает, что смерть одного клиента в процессе коммита транзакции не приведет к вечной блокировке других транзакций: они либо откатят незавершенный коммит, либо сделают сделают доступными те записи, которые успела подготовить умершая транзакция.
- Отказоустойчивости _TSO_.

Задание:

1. Предложите отказоустойчивый дизайн _TSO_ который обеспечивает высокую пропускную способность, т.е. позволяет генерировать сотни тысяч временных меток в секунду. Докажите, что ваша реализация обеспечивает монотонность. При соблюдении всех условий выше попробуйте оптимизировать латентность операции. Ваш дизайн не должен иметь зависимостей от внешних сервисов (использовать здесь _TrueTime_ не надо =). Монотонность должна быть обеспечена в асинхронной модели, без предположений о синхронности и дрейфе физических часов. 

2. Предложите дизайн _TSO_, который использует в качестве внешней зависимости [ZooKeeper](https://www.usenix.org/legacy/events/atc10/tech/full_papers/Hunt.pdf).
